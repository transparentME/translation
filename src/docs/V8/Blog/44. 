In this blog post we would like to explain how V8 handles JavaScript properties internally.
From a JavaScript point of view there are only a few distinctions necessary for properties.
JavaScript objects mostly behave like dictionaries, with string keys and arbitrary objects as values.
The specification does however treat integer-indexed properties and other properties differently during iteration.
Other than that, the different properties behave mostly the same, independent of whether they are integer indexed or not.
è¿™ç¯‡æ–‡ç« ï¼Œæˆ‘ä»¬å°†ä¼šé˜è¿°v8çš„å†…éƒ¨æ˜¯å¦‚ä½•å¤„ç†jså±æ€§çš„ã€‚
ä»jsçš„è§’åº¦æ¥çœ‹ï¼Œæœ‰ä¸€äº›çš„å±æ€§æ˜¯æœ‰ä¸åŒäºå…¶ä»–å±æ€§çš„ã€‚
jså¯¹è±¡å’Œå­—å…¸å¾ˆåƒï¼Œå­—ç¬¦ä¸²ä½œä¸ºå…³é”®è¯ï¼Œä»–çš„å«ä¹‰ä½œä¸ºä»–çš„valueå€¼ï¼›
ä½†æ˜¯å¯¹å¾…æ•´å‹çš„indexå±æ€§å’Œå¯¹å¾…å…¶ä»–ç±»å‹çš„å±æ€§æ˜¯ä¸ä¸€æ ·çš„ã€‚
é™¤æ­¤ä¹‹å¤–ï¼Œä¸åŒçš„å±æ€§å¤§è‡´çš„å¤„ç†æ–¹å¼éƒ½å¤§åŒå°å¼‚ï¼ŒåŒºåˆ«åœ¨äºä»–ä»¬æ˜¯ä¸æ˜¯æ•´å‹indexã€‚

However, under the hood V8 does rely on several different representations of properties for performance and memory reasons.
In this blog post we are going to explain how V8 can provide fast property access while handling dynamically-added properties.
Understanding how properties work is essential for explaining how optimizations such as inline caches work in V8.
ä½†æ˜¯ï¼Œv8ä¾èµ–äºä¸åŒçš„å±æ€§è¡¨ç°å½¢å¼ä»¥åœ¨æ€§èƒ½å’Œå†…å­˜æ–¹é¢å‘æŒ¥å¸®åŠ©ã€‚
åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†é˜è¿°v8æ˜¯å¦‚ä½•åœ¨å¤„ç†åŠ¨æ€æ·»åŠ å±æ€§æ—¶ï¼Œèƒ½å¿«é€Ÿè·å–å±æ€§ã€‚
äº†è§£å±æ€§æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œå°±èƒ½æ›´å¥½çš„ç†è§£ï¼Œå¦‚æœv8ä¸­çš„inline cacheçš„ä¼˜åŒ–äº†ã€‚

This post explains the difference in handling integer-indexed and named properties.
After that we show how V8 maintains HiddenClasses when adding named properties in order to provide a fast way to identify the shape of an object.
We'll then continue giving insights into how named properties are optimized for fast accesses or fast modification depending on the usage.
In the final section we provide details on how V8 handles integer-indexed properties or array indices.
è¿™ç¯‡æ–‡ç« è§£é‡Šäº†æ˜¯å¦‚ä½•å¤„ç†æ•´å‹indexå’Œå…·åå±æ€§çš„ã€‚
ä¹‹åï¼Œæˆ‘ä»¬å°†ä¼šå±•ç¤ºv8æ˜¯å¦‚ä½•ç»´æŠ¤hiddenClassçš„ï¼Œå½“æˆ‘ä»¬æ·»åŠ å…·åå±æ€§ä»¥æä¾›ä¸€ç§å¿«é€Ÿçš„æ–¹å¼å»è®¤å®šä¸€ä¸ªå¯¹è±¡çš„shapeï¼›
æ¥ç€æˆ‘ä»¬å°†ä¼šç»§ç»­èšç„¦åˆ°å…·åå±æ€§å¦‚ä½•é€šè¿‡ä½¿ç”¨çš„æ–¹å¼å»ä¼˜åŒ–ï¼Œå¯ä»¥è¾¾åˆ°å¿«é€Ÿè·å–çš„æˆ–å¿«é€Ÿä¿®æ”¹çš„ç›®çš„ã€‚
åœ¨æœ€åï¼Œæˆ‘ä»¬å°†ä¼šç»†ç»†è®²è§£v8æ˜¯å¦‚ä½•å¤„ç†æ•´å‹indexå±æ€§æˆ–æ•°å­—çš„ä¸‹æ ‡ã€‚

Named properties vs. elements

Let's start by analysing a very simple object such as {a: "foo", b: "bar"}.
This object has two named properties, "a" and "b".
It does not have any integer indices for property names.
Array-indexed properties, more commonly known as elements, are most prominent on arrays.
For instance the array ["foo", "bar"] has two array-indexed properties: 0, with the value "foo", and 1, with the value "bar".
This is the first major distinction on how V8 handles properties in general.
å‘½åå±æ€§ Vs å…ƒç´ 

æˆ‘ä»¬å…ˆä»ä¸€ä¸ªç®€å•çš„å¯¹è±¡{a: "foo", b: "bar"}å¼€å§‹å§ã€‚
è¿™ä¸ªå¯¹è±¡æœ‰ä¸¤ä¸ªå±æ€§ï¼Œaå’Œbã€‚
è¿™ä¸¤ä¸ªå±æ€§éƒ½ä¸æ˜¯æ•´å‹ä¸‹æ ‡ã€‚
æ•°å­—ä¸‹æ ‡å±æ€§ï¼Œä¹Ÿå°±æ˜¯é€šå¸¸è¢«æˆ‘ä»¬æ‰€è®¤ä¸ºçš„å…ƒç´ ï¼Œå¸¸å¸¸åœ¨æ•°ç»„ä¸­è¢«æˆ‘ä»¬æ‰€ç†Ÿè¯†ã€‚
ä¾‹å¦‚ï¼Œ["foo", "bar"]æœ‰ä¸¤ä¸ªæ•°ç»„ä¸‹æ ‡æŒ‡å‘çš„å±æ€§ï¼Œåˆ†åˆ«æ˜¯ï¼š0ï¼Œä»–çš„å€¼å¯¹åº”çš„æ˜¯fooï¼Œè€Œ1åˆ™å¯¹åº”çš„æ˜¯barï¼›
è¿™å°±æ˜¯v8å¤„ç†å±æ€§çš„æœ€ä¸»è¦çš„åŒºåˆ«ã€‚

The following diagram shows what a basic JavaScript object looks like in memory.
ä¸‹é¢è¿™å¼ å›¾å°±å±•ç¤ºäº†ä¸€ä¸ªæ™®é€šçš„jså¯¹è±¡åœ¨å†…å­˜é‡Œæ˜¯ä»€ä¹ˆæ ·çš„ã€‚
ï¿¼
Elements and properties are stored in two separate data structures which makes adding and accessing properties or elements more efficient for different usage patterns.
å…ƒç´ å’Œå¯¹è±¡æ˜¯æ˜¯å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„æ•°æ®ç»“æ„é‡Œé¢çš„ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—å¢åŠ æˆ–è€…è·å–å±æ€§æˆ–è€…å…ƒç´ çš„æ—¶å€™å¯ä»¥æ›´åŠ çš„é«˜æ•ˆï¼›

Elements are mainly used for the various Array.prototype methods such as pop or slice.
Given that these functions access properties in consecutive ranges, V8 also represents them as simple arrays internally â€” most of the time.
Later in this post we will explain how we sometimes switch to a sparse dictionary-based representation to save memory.
å…ƒç´ ä¸»è¦æ˜¯ç”¨æ¥ç»™ArrayåŸå‹é“¾ä¸Šé‚£äº›æ–¹æ³•ç”¨çš„ã€‚
åŸºäºè¿™äº›æ–¹æ³•ä¼šåœ¨è¿ç»­çš„èŒƒå›´å†…è·å–å±æ€§ï¼Œå› æ­¤v8åŒæ ·ä¼šåœ¨å¤§å¤šæ•°æ—¶é—´ä»¥ä¸€ç§ç®€å•æ•°ç»„çš„æ–¹å¼æ¥è¡¨è¾¾ä»–ä»¬ã€‚
è¿™ç¯‡æ–‡ç« åé¢ï¼Œæˆ‘ä»¬å°†ä¼šè§£é‡Šä¸€ä¸‹æˆ‘ä»¬æ˜¯å¦‚ä½•ä»¥ä¸€ç§å°‘è§çš„åŸºäºå­—å…¸çš„è¡¨è¾¾æ–¹å¼æ¥ä¿å­˜å†…å­˜ã€‚

Named properties are stored in a similar way in a separate array.
However, unlike elements, we cannot simply use the key to deduce their position within the properties array; we need some additional metadata.
In V8 every JavaScript object has a HiddenClass associated.
The HiddenClass stores information about the shape of an object, and among other things, a mapping from property names to indices into the properties.
To complicate things we sometimes use a dictionary for the properties instead of a simple array.
We will explain this in more detail in a dedicated section.
å‘½åå±æ€§ä»¥ä¸€ç§ç›¸ä¼¼çš„æ–¹å¼å­˜å‚¨åœ¨ä¸€ä¸ªåˆ†å¼€çš„æ•°ç»„é‡Œã€‚
ä½†æ˜¯ï¼Œä¸åŒäºå…ƒç´ çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸èƒ½åªæ˜¯é€šè¿‡keyå€¼æ¥æ¨æ–­ä»–ä»¬åœ¨å±æ€§æ•°ç»„ä¸­çš„ä½ç½®ï¼›æˆ‘ä»¬è¿˜éœ€è¦ä¸€äº›é™„åŠ çš„å…ƒæ•°æ®ã€‚
åœ¨v8ä¸­ï¼Œæ¯ä¸€ä¸ªjså¯¹è±¡éƒ½æœ‰ä¸€ä¸ªå…³è”çš„HiddenClassï¼›
è¿™ä¸ªHiddenClassä¸­å‚¨å­˜äº†å…³äºæŸä¸€ä¸ªå¯¹è±¡çš„shapeçš„ä¿¡æ¯ï¼Œè¿˜æœ‰ä¸€äº›å…¶ä»–ä¸œè¥¿ï¼Œå±æ€§åç§°åˆ°ç´¢å¼•çš„å±æ€§æ˜ å°„ã€‚
æˆ‘ä»¬æœ‰æ—¶å€™ä¼šç”¨ä¸€ä¸ªå±æ€§çš„å­—å…¸ï¼Œè€Œéä¸€ä¸ªç®€å•çš„æ•°ç»„ã€‚
è¿™ä¸ªéƒ¨åˆ†æˆ‘ä»¬å°†ä¼šä¸“é—¨æœ‰ä¸€ä¸ªå°èŠ‚æ¥è§£é‡Šã€‚

Takeaway from this section:
è¿™ä¸€å°èŠ‚çš„è¦ç‚¹ï¼š

1. Array-indexed properties are stored in a separate elements store.
	æ•°ç»„çš„ç´¢å¼•å±æ€§æ˜¯å­˜åœ¨ä¸€ä¸ªå•ç‹¬çš„å…ƒç´ ä¸­çš„ï¼›
1. Named properties are stored in the properties store.
	å‘½åçš„å±æ€§æ˜¯å­˜åœ¨å±æ€§ä¸­çš„ï¼›
1. Elements and properties can either be arrays or dictionaries.
	å…ƒç´ å’Œå±æ€§æ—¢å¯ä»¥æ˜¯æ•°ç»„ï¼Œä¹Ÿå¯ä»¥æ˜¯å­—å…¸ï¼›
4. Each JavaScript object has a HiddenClass associated that keeps information about the object shape.
	æ¯ä¸ªjså¯¹è±¡éƒ½æœ‰ä¸€ä¸ªç”¨äºå­˜å‚¨ä»–ä»¬çš„å¯¹è±¡shapeä¿¡æ¯çš„hiddenclass

HiddenClasses and DescriptorArrays

After explaining the general distinction of elements and named properties we need to have a look at how HiddenClasses work in V8.
This HiddenClass stores meta information about an object, including the number of properties on the object and a reference to the objectâ€™s prototype. 
HiddenClasses are conceptually similar to classes in typical object-oriented programming languages.
However, in a prototype-based language such as JavaScript it is generally not possible to know classes upfront.
Hence, in this case V8, HiddenClasses are created on the fly and updated dynamically as objects change.
HiddenClasses serve as an identifier for the shape of an object and as such a very important ingredient for V8's optimizing compiler and inline caches.
The optimizing compiler for instance can directly inline property accesses if it can ensure a compatible objects structure through the HiddenClass.
åœ¨è§£é‡Šå…ƒç´ ä¸å‘½åå±æ€§çš„åŒºåˆ«ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä¸€ä¸‹hiddenClassåœ¨v8ä¸­æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚
è¿™ä¸ªhiddenClassä¿å­˜å…³äºä¸€ä¸ªå¯¹è±¡çš„å…ƒä¿¡æ¯ï¼Œå…¶ä¸­åŒ…æ‹¬ï¼Œå¯¹è±¡çš„å±æ€§çš„æ•°é‡ï¼Œå’Œå¯¹è±¡çš„åŸå‹å¯¹è±¡çš„å¼•ç”¨ã€‚
hiddenClassä»æ¦‚å¿µä¸Šæ¥è¯´ï¼Œå’Œå…¸å‹çš„é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€ä¸­çš„ç±»å¾ˆç›¸ä¼¼ã€‚
ä½†æ˜¯ï¼Œåœ¨åŸºäºåŸå‹çš„è¯­è¨€ä¸­ï¼Œä¾‹å¦‚è¯´jsï¼Œå¦ç™½è¯´ï¼Œä»–å¹¶ä¸çŸ¥é“ç±»æ˜¯ä»€ä¹ˆã€‚
å› æ­¤ï¼Œhiddenclassså…¶å®æ˜¯ä¼šéšç€å¯¹è±¡çš„å˜åŒ–è€ŒåŠ¨æ€æ›´æ–°çš„ã€‚
hiddenClasså……å½“äº†ä¸€ä¸ªæ ‡è¯†ä¸€ä¸ªå¯¹è±¡çš„shapeçš„ä½œç”¨ï¼Œå¹¶ä¸”ä¹Ÿæ˜¯v8ä¼˜åŒ–ç¼–è¯‘å™¨å’Œinline cachesçš„ä¸€ä¸ªé‡è¦è§’è‰²ä¹‹ä¸€ã€‚
ä¾‹å¦‚ï¼Œä¼˜åŒ–ç¼–è¯‘å™¨å¯ä»¥ç›´æ¥å†…åµŒå±æ€§è®¿é—®ï¼Œå¦‚æœä»–å¯ä»¥é€šè¿‡hiddenclassæ¥ç¡®ä¿ä»–æ˜¯ä¸€ä¸ªå¯å…¼å®¹å¯¹è±¡ç»“æ„ã€‚

Let's have a look at the important parts of a HiddenClass.
æˆ‘ä»¬æ¥çœ‹ä¸‹hiddenclassçš„é‡ç‚¹éƒ¨åˆ†
ï¿¼

In V8 the first field of a JavaScript object points to a HiddenClass.
(In fact, this is the case for any object that is on the V8 heap and managed by the garbage collector.)
In terms of properties, the most important information is the third bit field, which stores the number of properties, and a pointer to the descriptor array.
The descriptor array contains information about named properties like the name itself and the position where the value is stored.
Note that we do not keep track of integer indexed properties here, hence there is no entry in the descriptor array.
åœ¨v8ä¸­ï¼Œjså¯¹è±¡çš„ç¬¬ä¸€éƒ¨åˆ†å°±æŒ‡å‘äº†hiddenclassã€‚
ï¼ˆå®é™…ä¸Šï¼Œåœ¨v8å †ä¸Šï¼Œå¹¶ä¸”è¢«gcç®¡ç†çš„å¯¹è±¡ç¡®å®æ˜¯å¦‚æ­¤ï¼‰
åœ¨å±æ€§æ–¹é¢ï¼Œæœ€é‡è¦çš„ä¿¡æ¯å°±æ˜¯ç¬¬ä¸‰bitä½çš„ï¼Œä¹Ÿå°±æ˜¯å­˜å‚¨è¿™å±æ€§æ•°é‡ï¼Œå¹¶æœ‰ä¸€ä¸ªæŒ‡å‘æè¿°ç¬¦æ•°ç»„ã€‚
æè¿°ç¬¦æ•°ç»„ä¸­åŒ…æ‹¬äº†å…³äºå‘½åå±æ€§çš„ä¸€äº›ä¿¡æ¯ï¼Œæ¯”å¦‚ï¼šåç§°å’Œå¯¹åº”å€¼æ‰€å­˜çš„ä½ç½®ã€‚
æ³¨æ„ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰åœ¨è¿™é‡Œè®°å½•è¿½è¸ªæ•´å‹æœç´¢å±æ€§ï¼Œå› æ­¤åœ¨æè¿°ç¬¦æ•°ç»„ä¸­æ˜¯æ²¡æœ‰å…¥å£çš„ã€‚

The basic assumption about HiddenClasses is that objects with the same structure â€” e.g. the same named properties in the same order â€” share the same HiddenClass.
To achieve that we use a different HiddenClass when a property gets added to an object.
In the following example we start from an empty object and add three named properties.
å¯¹hiddenClassçš„åŸºæœ¬å‡å®šå°±æ˜¯å¯¹è±¡éƒ½æœ‰ç›¸åŒçš„ç»“æ„ - ä¾‹å¦‚ï¼ŒåŒæ ·çš„å‘½åå±æ€§éƒ½æ˜¯ä»¥åŒæ ·çš„é¡ºåºæ’åˆ—çš„ - ä»–ä»¬ä¼šå…±äº«åŒæ ·çš„hidden classï¼›
å½“æŠŠä¸€ä¸ªå±æ€§åŠ åˆ°ä¸€ä¸ªå¯¹è±¡ä¸Šçš„æ—¶å€™ï¼Œæˆ‘ä»¬ç”¨äº†ä¸€ä¸ªä¸åŒçš„hiddenclassã€‚
åœ¨æ¥ä¸‹æ¥çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šå¯¹ä¸€ä¸ªç©ºçš„å¯¹è±¡ä¸­ï¼ŒåŠ å…¥ä¸‰ä¸ªå‘½åå±æ€§ã€‚
ï¿¼

Every time a new property is added, the object's HiddenClass is changed.
In the background V8 creates a transition tree that links the HiddenClasses together.
V8 knows which HiddenClass to take when you add, for instance, the property "a" to an empty object.
This transition tree makes sure you end up with the same final HiddenClass if you add the same properties in the same order.
The following example shows that we would follow the same transition tree even if we add simple indexed properties in between.
æ¯æ¬¡åªè¦æ–°çš„å¯¹è±¡åŠ è¿›å»ï¼Œå¯¹è±¡çš„hiddenClassä¹Ÿä¼šéšç€æ”¹å˜ã€‚
V8ä¼šåˆ›å»ºä¸€ä¸ªè¿‡æ¸¡æ ‘ç”¨æ¥æŠŠhiddenclassè”ç³»åœ¨ä¸€èµ·ã€‚
V8çŸ¥é“ï¼Œå½“ä½ åŠ å…¥æ–°çš„å±æ€§çš„æ—¶å€™ï¼Œåº”è¯¥å»å–å“ªä¸€ä¸ªhiddenclassï¼Œä¾‹å¦‚ï¼Œä½ å°†å±æ€§aåŠ å…¥åˆ°ä¸€ä¸ªç©ºçš„å¯¹è±¡ä¸­ã€‚
è¿™ä¸ªè¿‡æ¸¡æ ‘ä¼šç¡®ä¿ï¼Œå¦‚æœä½ å°†ä»¥ç›¸åŒçš„é¡ºåºå»åŠ å…¥çš„æ˜¯ç›¸åŒçš„å±æ€§ï¼Œé‚£ä¹ˆä½ æœ€ç»ˆä¼šå¾—åˆ°åŒæ ·çš„æœ€ç»ˆhiddenclassã€‚
æ¥ä¸‹æ¥çš„ä¾‹å­ï¼Œä¼šå±•ç¤ºå°½ç®¡æˆ‘ä»¬å°†ç®€å•çš„æœç´¢å±æ€§åŠ å…¥åˆ°å…¶ä¸­ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°åŒæ ·çš„è¿‡æ¸¡æ ‘ã€‚
ï¿¼
However, if we create a new object that gets a different property added, in this case property "d", V8 creates a separate branch for the new HiddenClasses.
ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œå¹¶ä¸”å¢åŠ äº†ä¸åŒçš„å±æ€§ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­dï¼Œv8å°†ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„åˆ†æ”¯ç”¨äºæ–°çš„hiddenclass
ï¿¼
Takeaway from this section:
è¿™ä¸€èŠ‚çš„è¦ç‚¹å¦‚ä¸‹ï¼š

1. Objects with the same structure (same properties in the same order) have the same HiddenClass
	æœ‰ç€åŒæ ·æ¥å£çš„å¯¹è±¡ï¼ˆæ¯”å¦‚è¯´åŒæ ·çš„å±æ€§ï¼Œå¹¶ä¸”æœ‰ç€åŒæ ·çš„é¡ºåºï¼‰ä¼šæ‹¥æœ‰åŒæ ·çš„hiddenclass
1. By default every new named property added causes a new HiddenClass to be created.
	é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¯ä¸ªæ–°çš„å‘½åå±æ€§çš„åŠ å…¥éƒ½ä¼šå¯¼è‡´æ–°çš„hiddenclassçš„åˆ›å»ºã€‚
1. Adding array-indexed properties does not create new HiddenClasses.
	æ·»åŠ æ•°ç»„ç´¢å¼•å‹çš„å±æ€§å¹¶ä¸ä¼šåˆ›å»ºæ–°çš„hiddenclass

The three different kinds of named properties
3ç§ä¸åŒç±»å‹çš„å‘½åå±æ€§

After giving an overview on how V8 uses HiddenClasses to track the shape of objects letâ€™s dive into how these properties are actually stored.
As explained in the introduction above, there are two fundamental kind of properties: named and indexed.
The following section covers named properties.
åœ¨æˆ‘ä»¬ç»™å‡ºv8æ˜¯å¦‚æœä½¿ç”¨hiddenclassä»¥è¿½è¸ªå¯¹è±¡çš„shapeçš„æ¦‚è¦ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆæ·±æŒ–ä¸€ä¸‹è¿™äº›å±æ€§çœŸæ­£æ˜¯å¦‚ä½•è¢«å‚¨å­˜çš„ã€‚
å°±åƒæ˜¯ä¸Šé¢ä»‹ç»ç« èŠ‚æ‰€è¯´çš„ï¼Œç°åœ¨æœ‰ä¸¤ç§åŸºç¡€ç±»å‹çš„å±æ€§ï¼šå…·åå±æ€§å’Œç´¢å¼•å±æ€§ã€‚
æ¥ä¸‹æ¥çš„å°èŠ‚è°ˆçš„æ˜¯å…·åå±æ€§ã€‚

A simple object such as {a: 1, b: 2} can have various internal representations in V8.
While JavaScript objects behave more or less like simple dictionaries from the outside, V8 tries to avoid dictionaries because they hamper certain optimizations such as inline caches which we will explain in a separate post.
ä¸€ä¸ªç®€å•å¯¹è±¡ï¼Œä¾‹å¦‚ {a: 1, b: 2} åœ¨v8ç§æœ‰è®¸å¤šå†…éƒ¨è¡¨ç¤ºã€‚
ç„¶è€Œjså¯¹è±¡çš„è¡Œä¸ºä»å¤–éƒ¨æ¥çœ‹æˆ–å¤šæˆ–å°‘çš„åƒæ˜¯ç®€å•å­—å…¸ä¸€èˆ¬ï¼Œv8è¯•ç€å»é¿å…å­—å…¸èˆ¬çš„ï¼ˆâ€¦ï¼‰å› ä¸ºä»–ä»¬ä¼šæŸç¼šä½æŸç§ç‰¹å®šçš„ä¼˜åŒ–ï¼Œæ¯”æ–¹è¯´inline cachesï¼Œè¿™ä¸ªæˆ‘ä»¬å°†ä¼šåœ¨å¦å¤–ä¸€ä¸ªå•ç‹¬çš„æ–‡ç« ä¸­è¯´ã€‚

In-object vs. normal properties:

V8 supports so-called in-object properties which are stored directly on the object themselves.
These are the fastest properties available in V8 as they are accessible without any indirection.
The number of in-object properties is predetermined by the initial size of the object.
If more properties get added than there is space in the object, they are stored in the properties store.
The properties store adds one level of indirection but can be grown independently.
in-object ä¸ æ™®é€šå±æ€§ï¼š
V8æ”¯æŒæ‰€è°“çš„in-objectå±æ€§ï¼Œè¿™ç§å±æ€§æ˜¯ç›´æ¥å­˜å‚¨åœ¨å¯¹è±¡ä¸­çš„ã€‚
åœ¨v8ä¸­ï¼Œä»–ä»¬æ˜¯æœ€å¿«æ·çš„è·å–çš„å±æ€§ï¼Œå› ä¸ºå¯ä»¥ç›´æ¥è·å–ä»–ä»¬ã€‚
In-objectå±æ€§çš„æ•°é‡æ˜¯é¢„å…ˆç”±å¯¹è±¡çš„åˆå§‹å¤§å°æ‰€å†³å®šçš„ã€‚
å¦‚æœåŠ å…¥çš„å±æ€§å¤šäºå¯¹è±¡çš„ç©ºé—´ï¼Œé‚£ä¹ˆä»–ä»¬å°±ä¼šè¢«å­˜å‚¨åœ¨å±æ€§ä»“ä¸­ã€‚
å±æ€§ä»“ä¸­å°±å¢åŠ äº†ä¸€å±‚é—´æ¥è·å–ï¼Œä»–ä»¬å¯ä»¥è‡ªä¸»çš„å¤§å¢ç©ºé—´ã€‚
ï¿¼
Fast vs. slow properties:
The next important distinction is between fast and slow properties.
Typically we define the properties stored in the linear properties store as "fast".
Fast properties are simply accessed by index in the properties store.
To get from the name of the property to the actual position in the properties store, we have to consult the descriptor array on the HiddenClass, as we've outlined before.
å¿«å±æ€§ vs æ…¢å±æ€§ï¼š
è¿˜æœ‰ä¸€ä¸ªé‡è¦çš„åŒºåˆ«å°±æ˜¯å¿«æ…¢å±æ€§ï¼›
æˆ‘ä»¬ä¸€èˆ¬å®šä¹‰çš„å±æ€§éƒ½å­˜å‚¨åœ¨çº¿æ€§å±æ€§ä¸­ï¼Œæ˜¯å±äºâ€œå¿«â€å±æ€§ï¼›
å¿«å±æ€§éƒ½æ˜¯é€šè¿‡ç´¢å¼•çš„æ–¹å¼åœ¨å±æ€§åº“ä¸­è·å–ã€‚
ä¸ºäº†èƒ½åœ¨å±æ€§åº“çš„çœŸå®ä½ç½®ä¸­è·å–å±æ€§ï¼Œæˆ‘ä»¬å¿…é¡»è¦é—®ä¸Šé¢æˆ‘ä»¬æ‰€æåˆ°çš„hiddenclassä¸­çš„æè¿°æ•°ç»„ã€‚
ï¿¼


However, if many properties get added and deleted from an object, it can generate a lot of time and memory overhead to maintain the descriptor array and HiddenClasses.
Hence, V8 also supports so-called slow properties.
An object with slow properties has a self-contained dictionary as a properties store.
All the properties meta information is no longer stored in the descriptor array on the HiddenClass but directly in the properties dictionary.
Hence, properties can be added and removed without updating the HiddenClass.
Since inline caches donâ€™t work with dictionary properties, the latter, are typically slower than fast properties.
ä½†æ˜¯ï¼Œåœ¨ä¸€ä¸ªå¯¹è±¡ä¸Šåšå¤šæ¬¡æ·»åŠ æˆ–åˆ é™¤æ“ä½œï¼Œä»–ä¼šæ¶ˆè€—å¾ˆå¤šæ—¶é—´å’Œç©ºé—´å»ç»´æŠ¤æè¿°ç¬¦æ•°ç»„å’Œhiddenclassï¼›
å› æ­¤ï¼Œv8åŒæ ·ä¹Ÿæ”¯æŒæ‰€è°“çš„æ…¢å±æ€§ã€‚
ä¸€ä¸ªæ‹¥æœ‰æ…¢å±æ€§çš„å¯¹è±¡ä»–è‡ªå·±æœ‰ä¸€å¥—ç‹¬ç«‹çš„å±æ€§ä»“åº“ã€‚
æ‰€æœ‰å±æ€§çš„å…ƒä¿¡æ¯éƒ½ä¸ä¼šå­˜åœ¨åœ¨hiddenclassçš„æè¿°ç¬¦æ•°ç»„ä¸­ï¼Œè€Œæ˜¯ç›´æ¥å­˜åœ¨å±æ€§å­—å…¸ä¸­ã€‚
å› æ­¤ï¼Œå±æ€§å¯ä»¥åœ¨ä¸æ›´æ–°hiddenclassçš„æ¡ä»¶ä¸‹æ·»åŠ æˆ–åˆ é™¤å¾ˆå¤šæ¬¡ã€‚
å› ä¸ºinline cacheä¸ä¸å­—å…¸å±æ€§ä¸€èµ·å·¥ä½œï¼Œå› ä¸ºåè€…æ¯”å¿«å±æ€§æ…¢ã€‚

Takeaway from this section:
è¿™ä¸ªç« èŠ‚çš„è¦ç‚¹ï¼š

There are three different named property types: in-object, fast and slow/dictionary.
In-object properties are stored directly on the object itself and provide the fastest access.
Fast properties live in the properties store, all the meta information is stored in the descriptor array on the HiddenClass.
Slow properties live in a self-contained properties dictionary, meta information is no longer shared through the HiddenClass.
Slow properties allow for efficient property removal and addition but are slower to access than the other two types.
ç°åœ¨æœ‰ä¸‰ç§å‘½åå±æ€§ç±»å‹ï¼šin-objectã€å¿«å±æ€§ã€æ…¢å±æ€§ï¼›
1. In-objectå±æ€§æ˜¯ç›´æ¥å­˜åœ¨åœ¨å¯¹è±¡æœ¬èº«ï¼Œå¹¶ä¸”æ˜¯æœ€å¿«èƒ½è·å–åˆ°çš„å±æ€§ã€‚
2. å¿«å±æ€§åœ¨å±æ€§ä»“åº“ä¸­ï¼Œæ‰€æœ‰çš„å…ƒä¿¡æ¯éƒ½å­˜åœ¨hiddenclassçš„æè¿°ç¬¦æ•°ç»„ä¸­ï¼›
3. æ…¢å±æ€§åœ¨æœ‰ç‹¬ç«‹çš„å±æ€§å­—å…¸ï¼Œå…ƒä¿¡æ¯ä¸é€šè¿‡hiddenclassè¯»å–ï¼›
æ…¢å±æ€§å…è®¸æœ‰æ•ˆçš„åˆ é™¤å’Œå¢åŠ å±æ€§ï¼Œä½†æ˜¯æ¯”å¦å¤–ä¸¤ç§éƒ½è¦æ…¢ï¼›

Elements or array-indexed properties

So far we have looked at named properties and ignored integer indexed properties commonly used with arrays. 
Handling of integer indexed properties is no less complex than named properties.
Even though all indexed properties are always kept separately in the elements store, there are 20 different types of elements!
åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»äº†è§£äº†å‘½åå±æ€§å’Œå¿½ç•¥çš„æ•´å‹ç´¢å¼•å±æ€§ã€‚
å¤„ç†æ•´å‹ç´¢å¼•çš„å±æ€§ä¹Ÿä¸æ¯”å‘½åå±æ€§ç®€å•ã€‚
å°½ç®¡æ‰€æœ‰çš„ç´¢å¼•å±æ€§éƒ½æ˜¯åˆ†å¼€åœ¨å…ƒç´ ä»“åº“ä¸­å­˜å‚¨çš„ï¼Œä½†æ˜¯ç°åœ¨æœ‰20ç§ä¸åŒç±»å‹çš„å…ƒç´ ã€‚

Packed or Holey Elements:
åŒ…è£… æˆ–è€… æ¼æ´å…ƒç´ ï¼š

The first major distinction V8 makes is whether the elements backing store is packed or has holes in it.
You get holes in a backing store if you delete an indexed element, or for instance, you don't define it.
A simple example is [1,,3] where the second entry is a hole.
The following example illustrates this issue:
ç¬¬ä¸€ä¸ªæœ€ä¸»è¦çš„v8æ‰€åšçš„åŒºåˆ†ï¼Œå°±æ˜¯æ˜¯å¦å…ƒç´ çš„å¤‡ä»½å­˜å‚¨æ˜¯æ»¡çš„ è¿˜æ˜¯ æœ‰æ¼æ´çš„ï¼›
å¦‚æœä½ åˆ é™¤äº†ä¸€ä¸ªç´¢å¼•å…ƒç´ ï¼Œæˆ–è€…ä½ æ²¡æœ‰å®šä¹‰å®ƒï¼Œé‚£ä¹ˆä½ å°†åœ¨backing storeä¸­è·å¾—ä¸€ä¸ªæ´ã€‚
ç®€å•çš„é‡Œé¢å°±æ˜¯[1,,3],ç¬¬äºŒä¸ªå…¥å£æ˜¯ä¸€ä¸ªæ´ã€‚
ä¸‹é¢çš„ä¾‹å­å°±è§£é‡Šäº†è¿™ä¸ªé—®é¢˜ï¼š

const o = ['a', 'b', 'c'];
console.log(o[1]);          // Prints 'b'.
					æ‰“å°b
delete o[1];                // Introduces a hole in the elements store.
					åœ¨å…ƒç´ ä»“åº“ä¸­ï¼Œå¼•å…¥ä¸€ä¸ªæ´
console.log(o[1]);          // Prints 'undefined'; property 1 does not exist.
					æ‰“å°æ˜¯çš„æ˜¯undefinedï¼›å±æ€§1ä¸å­˜åœ¨ï¼›
o.__proto__ = {1: 'B'};     // Define property 1 on the prototype.
					å®šä¹‰ä¸€ä¸ª1åœ¨åŸå‹ä¸Šï¼›
console.log(o[0]);          // Prints 'a'.
console.log(o[1]);          // Prints 'B'.
console.log(o[2]);          // Prints 'c'.
console.log(o[3]);          // Prints undefined
ï¿¼
In short, if a property is not present on the receiver we have to keep on looking on the prototype chain.
Given that elements are self-contained, e.g. we don't store information about present indexed properties on the HiddenClass, we need a special value, called the_hole, to mark properties that are not present.
This is crucial for the performance of Array functions.
If we know that there are no holes, i.e. the elements store is packed, we can perform local operations without expensive lookups on the prototype chain.
ç®€å•æ¥è¯´ï¼Œå¦‚æœä¸€ä¸ªå±æ€§æ²¡æœ‰åœ¨å¯¹è±¡ä¸Šæ‰¾åˆ°ï¼Œ æˆ‘ä»¬å°±è¦å»æŸ¥æ‰¾åŸå‹é“¾ï¼›
è€ƒè™‘åˆ°å…ƒç´ æ˜¯ç‹¬ç«‹çš„ï¼Œä¾‹å¦‚ï¼Œæˆ‘ä»¬ä¸ä¼šåœ¨hiddenclassä¸Šå­˜å‚¨ç°åœ¨çš„ç´¢å¼•å±æ€§çš„ä¿¡æ¯ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç‰¹æ®Šçš„å€¼ï¼Œç§°ä¹‹ä¸ºğŸ•³ï¸æ´ï¼Œç”¨æ¥æ ‡è®°é‚£äº›æ²¡æœ‰å±•ç¤ºçš„å±æ€§ã€‚
è¿™å¯¹äºArrayçš„å‡½æ•°çš„æ€§èƒ½æ¥è¯´æ˜¯å¾ˆé‡è¦çš„ã€‚
å¦‚æœæˆ‘ä»¬çŸ¥é“ï¼Œè¿™æ²¡æœ‰æ´ï¼Œä¾‹å¦‚ï¼Œå…ƒç´ ä»“åº“æ˜¯å®Œæ•´çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä¸ç”¨ç”¨å¾ˆå¤§çš„å¼€é”€å‘ä¸ŠæŸ¥æ‰¾åŸå‹é“¾å»åšæœ¬åœ°çš„æ“ä½œã€‚

Fast or Dictionary Elements: The second major distinction made on elements is whether they are fast or dictionary-mode.
Fast elements are simple VM-internal arrays where the property index maps to the index in the elements store.
However, this simple representation is rather wasteful for very large sparse/holey arrays where only few entries are occupied.
In this case we used a dictionary-based representation to save memory at the cost of slightly slower access:
å¿«å…ƒç´  è¿˜æ˜¯ å­—å…¸å…ƒç´ ï¼š
è¿™æ˜¯å…ƒç´ çš„ç¬¬äºŒä¸ªä¸»è¦çš„åŒºåˆ†ï¼Œä»–ä»¬æ˜¯å¦æ˜¯å¿«å…ƒç´ è¿˜æ˜¯å­—å…¸æ¨¡å¼ã€‚
å¿«å…ƒç´ å…¶å®å°±æ˜¯å•çº¯çš„vm-å†…éƒ¨æ•°ç»„ï¼Œåœ¨è¿™é‡Œï¼Œå±æ€§ç´¢å¼•ä¼šæ˜ å°„åˆ°å¯¹åº”å…ƒç´ ä»“åº“çš„ç´¢å¼•ä¸­ã€‚
ä½†æ˜¯ï¼Œè¿™ç§ç®€å•çš„è¡¨ç¤ºæ–¹å¼å¯¹äºæ²¡æœ‰ç¨€ç–çš„æˆ–æ˜¯æœ‰æ´çš„æ•°ç»„æ˜¯å¾ˆæµªè´¹çš„ï¼Œå› ä¸ºåªæœ‰å¾ˆå°‘çš„å®ä¾‹ä¼šè¢«å ç”¨ã€‚
å› æ­¤ï¼Œæˆ‘ä»¬å°±ä¼šä½¿ç”¨å­—å…¸å‹è¡¨è¾¾æ–¹å¼æ¥èŠ‚çœå†…å­˜ç©ºé—´ï¼Œå½“ç„¶ä»£ä»·å°±æ˜¯è·å–çš„é€Ÿåº¦æœ‰ä¸€ç‚¹ç‚¹æ…¢ï¼›

const sparseArray = [];
sparseArray[9999] = 'foo'; // Creates an array with dictionary elements.
						è¿™æ ·å°±ä¼šåˆ›å»ºä¸€ä¸ªå­—å…¸å‹å…ƒç´ ã€‚

In this example, allocating a full array with 10k entries would be rather wasteful.
What happens instead is that V8 creates a dictionary where we store a key-value-descriptor triplets.
The key in this case would be '9999' and the value 'foo' and the default descriptor is used.
Given that we don't have a way to store descriptor details on the HiddenClass, V8 resorts to slow elements whenever you define an indexed properties with a custom descriptor:
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œåˆ†é…ä¸€ä¸ªèƒ½è£…å¾—ä¸‹10kä¸ªå…ƒç´ çš„æ•°ç»„æ˜¯ç›¸å½“æµªè´¹çš„ã€‚
é‚£ä¹ˆåœ¨v8ä¸­ï¼Œåˆ™ä¼šåˆ›å»ºä¸€ä¸ªå­—å…¸ï¼Œè¿™ä¸ªå­—å…¸ä¸­æœ‰ key-value-æè¿°ç¬¦ã€‚
9999å°±æ˜¯ä»–çš„keyï¼Œvalueæ˜¯fooï¼Œç„¶åä½¿ç”¨é»˜è®¤çš„æè¿°ç¬¦ã€‚
è€ƒè™‘åˆ°æˆ‘ä»¬æ²¡æœ‰ä¸èƒ½æŠŠdescriptorç»†èŠ‚å­˜åœ¨hiddenclassä¸Šï¼Œv8å°±è¯‰è¯¸äºä¸€ä¸ªæ…¢å¯¹è±¡ï¼Œå½“ä½ å®šä¹‰äº†ä¸€ä¸ªå¸¦æœ‰è‡ªå®šä¹‰æè¿°ç¬¦çš„ç´¢å¼•å±æ€§ã€‚

const array = [];
Object.defineProperty(array, 0, {value: 'fixed' configurable: false});
console.log(array[0]);      // Prints 'fixed'.
array[0] = 'other value';   // Cannot override index 0.
console.log(array[0]);      // Still prints 'fixed'.

In this example we added a non-configurable property on the array.
This information is stored in the descriptor part of a slow elements dictionary triplet.
It is important to note that Array functions perform considerably slower on objects with slow elements.
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªä¸å¯é…ç½®å±æ€§åˆ°æ•°ç»„ä¸Šã€‚
è¿™ä¸ªä¿¡æ¯è¢«å­˜å‚¨åˆ°ä¸€ä¸ªæ…¢å…ƒç´ åˆ°å­—å…¸å†Œä¸­ã€‚
éœ€è¦æ³¨æ„çš„æ˜¯Arrayå‡½æ•°ï¼Œåœ¨æ‰§è¡Œä¸€ä¸ªå¸¦ç€æ…¢å…ƒç´ çš„å¯¹è±¡æ˜¯å¾ˆæ…¢çš„ã€‚

Smi and Double Elements:
å°æ•´å‹å’ŒåŒç²¾åº¦å…ƒç´ 
For fast elements there is another important distinction made in V8.
For instance if you only store integers in an Array, a common use-case, the GC does not have to look at the array, as integers are directly encoded as so called small integers (Smis) in place.
Another special case are Arrays that only contain doubles.
Unlike Smis, floating point numbers are usually represented as full objects occupying several words.
However, V8 stores raw doubles for pure double arrays to avoid memory and performance overhead.
The following example lists 4 examples of Smi and double elements:
å¯¹äºå¿«å…ƒç´ æ¥è¯´ï¼Œv8å¹¶æ²¡æ²¡æœ‰åšä»€ä¹ˆç‰¹åˆ«é‡è¦çš„åŒºåˆ†ã€‚
ä¾‹å¦‚ï¼Œå¦‚æœä½ åœ¨arrayä¸­åªå­˜äº†æ•´æ•°ï¼Œè¿™ç§ä¸€èˆ¬ç”¨æ³•ï¼Œgcéƒ½ä¸ä¸€å®šéœ€è¦å»çœ‹æ•°å­—ï¼Œå› ä¸ºæ•°å­—ä¼šç›´æ¥è¢«ç¼–ç æˆå°æ•´å‹ï¼ˆSmisï¼‰ã€‚
å¦ä¸€ä¸ªç‰¹åˆ«çš„ä¾‹å­æ˜¯ï¼Œæ•°ç»„ä¸­åªå­˜äº†åŒç²¾åº¦æ•°å­—ã€‚
ä¸smisä¸åŒï¼Œæµ®ç‚¹æ•°é€šå¸¸éƒ½è¢«
ä½†æ˜¯ï¼Œv8å­˜å‚¨raw doublesæ¥å­˜çº¯åŒç²¾åº¦æ•°ç»„ä»¥é¿å…è¿‡å¤šçš„ç©ºé—´ä¸æ€§èƒ½çš„å¼€é”€ã€‚
ä¸‹é¢4ä¸ªä¾‹å­åˆ—ä¸¾äº†4ä¸ªå…³äºå°æ•´å‹å’ŒåŒç²¾åº¦å…ƒç´ ï¼š

const a1 = [1,   2, 3];  // Smi Packed
					å®Œæ•´å°æ•´å‹
const a2 = [1,    , 3];  // Smi Holey, a2[1] reads from the prototype
					æ¼æ´å°æ•´å‹ï¼Œa2[1]æ˜¯ä»åŸå‹é“¾ä¸Šè¯»å–
const b1 = [1.1, 2, 3];  // Double Packed
					å®Œæ•´åŒæµ®ç‚¹
const b2 = [1.1,  , 3];  // Double Holey, b2[1] reads from the prototype
					æ¼æ´åŒæµ®ç‚¹ï¼Œb2[1]ä»åŸå‹é“¾ä¸Šè¯»å–

Special Elements:
With the information so far we covered 7 out of the 20 different element kinds.
For simplicity we excluded 9 element kinds for TypedArrays, two more for String wrappers and last but not least, two more special element kinds for arguments objects.
ç‰¹æ®Šå…ƒç´ ï¼š
ä¸Šé¢æåˆ°çš„20ç§ä¸åŒçš„å…ƒç´ ç±»å‹ä¸­çš„7ç§ã€‚
ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæˆ‘ä»¬æ’é™¤äº†9ç§TypedArraysç±»å‹ï¼Œ2ç§å­—ç¬¦ä¸²åŒ…è£¹å™¨ï¼Œè¿˜æœ‰2ç§ç‰¹æ®Šå‚æ•°å¯¹è±¡å…ƒç´ ã€‚

The ElementsAccessor:
å…ƒç´ å­˜å–å™¨ï¼š

As you can imagine we are not exactly keen on writing Array functions 20 times in C++, once for every elements kind.
That's where some C++ magic comes into play.
Instead of implementing Array functions over and over again, we built the ElementsAccessor where we mostly have to implement only simple functions that access elements from the backing store.
The ElementsAccessor relies on CRTP to create specialized versions of each Array function.
So if you call something like slice on an array, V8 internally calls a builtin written in C++ and dispatches through the ElementsAccessor to the specialized version of the function:

æ­£å¦‚ä½ æ‰€æƒ³çš„é‚£æ ·ï¼Œæˆ‘ä»¬å¹¶ä¸æƒ³åœ¨c++ä¸­å†™å¯¹æ¯ä¸€ä¸ªç±»å‹çš„å…ƒç´ å†™20æ¬¡Arrayå‡½æ•°ã€‚
è€Œè¿™ä¹Ÿå°±æ˜¯c++ä¸Šåœºçš„æ—¶å€™ã€‚
æˆ‘ä»¬æ„å»ºäº†å…ƒç´ å­˜å–å™¨ï¼Œä¾èµ–äºä»–ï¼Œæˆ‘ä»¬åªéœ€è¦å®ç°ç®€å•çš„å‡½æ•°ï¼Œç„¶åä¼ å…¥ä»å¤‡ä»½åº“ä¸­å–å‡ºçš„å…ƒç´ ï¼Œè€Œæ— éœ€ä¸€æ¬¡åˆä¸€æ¬¡çš„å»å®ç°æ•°ç»„çš„å‡½æ•°ã€‚
å…ƒç´ å­˜å–å™¨ä¾èµ–äº CRTPåˆ›å»ºä¸åŒç‰ˆæœ¬çš„Arrayå‡½æ•°ã€‚
å› æ­¤å¦‚æœä½ å¯¹ä¸€ä¸ªæ•°ç»„è°ƒç”¨ä¸€ä¸ªæ–¹æ³•ï¼Œæ¯”æ–¹æ˜¯sliceï¼Œv8çš„å†…éƒ¨ä¼šè°ƒç”¨ä¸€ä¸ªç”¨c++å†™çš„å†…å»ºå‡½æ•°ï¼Œå¹¶ä¸”é€šè¿‡å…ƒç´ å­˜å–å™¨å»æ´¾é£ç‰¹å®šç‰ˆæœ¬çš„å‡½æ•°
ï¿¼

Takeaway from this section:
è¿™ä¸ªç« èŠ‚çš„è¦ç‚¹ï¼š

There are fast and dictionary-mode indexed properties and elements.
Fast properties can be packed or they can contain holes which indicate that an indexed property has been deleted.
Elements are specialized on their content to speed up Array functions and reduce GC overhead.
Understanding how properties work is key to many optimizations in V8.
For JavaScript developers many of these internal decisions are not visible directly, but they explain why certain code patterns are faster than others.
Changing the property or element type typically causes V8 to create a different HiddenClass which can lead to type pollution which prevents V8 from generating optimal code.
Stay tuned for further posts on how the VM-internals of V8 work.
ç°æœ‰å¿«å±æ€§ã€å¿«å…ƒç´ ã€å­—å…¸æ¨¡å¼ç´¢å¼•çš„å±æ€§å’Œå…ƒç´ ã€‚
å¿«å±æ€§å¯ä»¥æ˜¯å®Œæ•´çš„æˆ–è€…ä¹Ÿå¯ä»¥æ˜¯æœ‰æ´çš„ï¼Œæœ‰æ´å°±è¡¨ç¤ºï¼Œä¸€ä¸ªç´¢å¼•å±æ€§è¢«åˆ é™¤äº†ã€‚

èƒ½ç†è§£å±æ€§æ˜¯å¦‚ä½•å·¥ä½œçš„æ˜¯åœ¨v8ä¸­ä¼˜åŒ–çš„å…³é”®ã€‚
å¯¹äºjså¼€å‘è€…ä»¬æ¥è¯´ï¼Œå¾ˆå¤šå†…éƒ¨çš„è¿™äº›å†³ç­–éƒ½ä¸æ˜¯ç›´æ¥å¯è§çš„ï¼Œä¹Ÿå°±æ˜¯ä»–ä»¬ï¼Œå¯ä»¥è§£é‡Šä¸ºä»€ä¹ˆæŸäº›ä»£ç çš„æ¨¡å¼æ˜¯å¿«ä¸å…¶ä»–çš„æ¨¡å¼çš„ã€‚
æ”¹å˜å±æ€§æˆ–ç±»å‹æ˜¯å…¸å‹çš„ä¼šå¯¼è‡´v8åˆ›é€ ä¸åŒhiddenclassçš„æ–¹å¼ï¼Œä¹Ÿæ˜¯å¦‚æ­¤ï¼Œä»–å¯èƒ½ä¼šå¯¼è‡´ç±»å‹æ±¡æŸ“ï¼Œä»è€Œä½¿å¾—éš¾ä»¥å†™å‡ºæœ€ä½³ä»£ç ã€‚
ç»§ç»­å…³æ³¨æˆ‘ä»¬ï¼Œæ¥äº†è§£v8å†…éƒ¨çš„vm-å†…éƒ¨æ˜¯æ€ä¹ˆå·¥ä½œçš„ã€‚